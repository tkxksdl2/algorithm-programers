### 경주로 건설
link : [경주로 건설](https://programmers.co.kr/learn/courses/30/lessons/67259)

-----------------------------------
 
 시작과 끝을 잇는 최소 비용 경로를 찾는 문제.

 일반 도로는 100원, 코너가 있는 경우는 500원이 추가된다.

 도로의 최소 개수는 ㄱ자 혹은 ㄴ자로 외곽을 도는 경우로, 여기서 코너를 늘릴 때 마다

 500원씩 추가되고, 도로의 개수는 늘거나 그대로이다. 더 줄어들 수는 없다.

 때문에 끝까지 갈 수 있는 모든 경로 중, 코너가 더 적을수록 무조건 비용이 더 싸다.

 그래서 bfs를 이용해 코너의 개수를 늘려가며 가능한 모든 경우의 수를 찾고,

 목적지에 도착하면 cost를 저장하도록 했다.

-----------------------------------------
 
 시작점이 주어지면, 각 시작점으로부터 상하좌우 방향으로 길이 막히거나 방문한 적 있는

 위치를 만날 때 까지 직선 위치를 모두 저장한다.

 저장된 위치는 코너 수가 하나 늘어난 다음 분기의 시작점이된다.

 방문한 위치는 checked 집합에 저장되고, 이를이용해 중복검사를 한다.

 그러나 방문할 때 마다 위치가 저장이 되면, 같은 코너수의 분기를 방해할 가능성이 있다.

 때문에 임시로 저장해 두었다가. 그 코너수의 분기가 모두 끝나면 한꺼번에 checked에 저장한다.

 즉 이전 코너 수 분기에 방문하지 않은 곳만 방문할 수 있다.

        if corner+1 >max_corner:
            max_corner += 1
            checked = checked.union(checking_temp)
            checking_temp = set()

 이 방법으로 최소 코너의 수가 최소인 경로를 구할 수 있다.

 그러나 코너 수가 같은 경로 사이에서 드물게 비용이 더 비싼 경로가

 비용이 더 싼 경로의 분기를 방해하는 경우가 생길 수 있다.

 이를 해결하기 위해 각 타일에 직전분기까지의 비용을 저장해놓고,  
 
 중복이더라도 현재 비용이 더 싸다면 중복검사를 통과할 수 있도록 했다.

    cost_dict = {(0,0):0}

        while 0<= next[0] < n and 0 <= next[1] < n and \
                    ((next[0], next[1]) not in checked or cost < cost_dict[(next[0],next[1])])\
                    and board[next[0]][next[1]] == 0:

                    res.append(next)
                    cost_dict[(next[0],next[1])] = cost
                    checking_temp.add((next[0], next[1]))
                    next = (next[0]+dy[i], next[1]+dx[i], corner +1 ,next[3]+100)

 -------------------------

 문제는 잘 풀었지만 코너 수를 기반으로 문제를 풀다 보니 로직이 약간 

 더러워 진 것 같다. 차라리 처음부터 비용 기반으로 풀었으면 더 깔끔했을지도 모르겠다.
 