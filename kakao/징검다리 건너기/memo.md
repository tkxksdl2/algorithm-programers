### 징검다리 건너기
link : [징검다리 건너기 kakao 2019](https://programmers.co.kr/learn/courses/30/lessons/64062)

--------------------------------------------

처음엔 stones 1번의 순회로 문제를 풀 수 있다고 생각해 슬라이딩 윈도우를

이용해 문제를 풀었다. 이동하는 k 길이의 구간에서 가장 큰 값이

그 구간이 커버할 수 있는 인원수이고,

이 커버 가능한 인원수 중 가장 작은 값이 전체 구간의 커버 가능한 값이다.

로직에는 문제가 없어서 정확성 검증은 통과했지만, 효율성 검정을 모두 실패했다.

k의 길이가 적절히 길어진다면 각 구간의 최대값을 구하는 로직이 너무 길어져

오히려 복잡도를 크게 증가시켰다. O(len(stone)-k) * O(k)의 복잡도로,

len(stone)이 최대값인 200,000이고, k가 그 절반인 100,000이라면,

복잡도는 O(100,000^2)로 O(100,000,000,000)이라는 큰 수가 된다.

--------------------------------------------

이를 풀기 위해 이진탐색으로 접근해보았다.

결정해야 하는것은 지나가는 사람의 숫자이고, 결과값은 통과할 수 있느냐 없느냐이다.

지나가는 사람의 숫자는 특정 값 아래로는 전부 통과하고,

그 값 위로는 전부 불통이다.

즉 결과값이 0:통과, 1:불통 인 리스트에서 0의 가장 우측 값을 탐색하는 것과 같다.

시작 인덱스는 min(stone)이고, 끝 인덱스는 max(stone)이다.

일반적인 bisect_right와 비슷하다고 생각할 수 있는데, 사실 약간다르다.

0이 들어갈 수 있는 가장 우측값(마지막 0 위치 +1) 을 찾는것이 아니라,

그 경계값 자체(마지막 0 위치) 를 찾아야 한다.

그래서 경계값 갱신에 약간 애를 먹었는데, 결국엔 올바르게 코딩에 성공했다.

    while s < e:
        mid = (s+e) // 2 + 1
        cnt = 0

        for n in stones:
            if n < mid: cnt += 1
            else: cnt = 0
            if cnt == k: break
        
        if cnt == k: e = mid-1
        else: s = mid
    
    return s

mid가 중간값의 +1이 되므로, 단 두개의 인덱스만 남았을 때, 우측 인덱스가 선택된다.

이를 보정하기 위해, 결과값이 불통인경우 중간값은 포함되지 않도록 e=mid-1 이다.

즉 언제나 마지막에는 통과값이 나오는 우측 끝 인덱스가 나오게 된다.

이렇게 되면 stones의 값 범위는 최대 200,000,000 이므로,

O(log(200,000,000)) = 약 27정도이고,

각 검증 당 최대 len(stones) 값 200,000 정도의 순회를 돎으로,

27 * 200,000 정도의 적은 복잡도로 문제를 해결할 수 있다.
