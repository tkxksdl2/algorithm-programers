### 미로탈출
link : [미로탈출](https://programmers.co.kr/learn/courses/30/lessons/81304)

-----------------------------------

일반적인 최소거리문제를 다소 꼬아낸 문제인데,

풀이를 함에 있어서 몇가지 문제가 있다.

1. trap을 방문할 때 마다 단위 노드의 값이 매번 바뀐다.

2. trap 때문에 같은 노드를 여러 번 방문해야하는 일이 생기는데, 이러면
    
    기존의 최소거리 기반 다익스트라 알고리즘으로는 노드를 이어나갈 수가 없다.

    같은곳을 두번 방문할 경우 이전에 방문했을 때 보다 시간이 길어져 갱신이 되지 않기 때문이다.

3. BFS를 사용할 경우 역시 중복방문을 처리할 방법을 고안해야 한다.

    자칫 잘못하면 무한루프에 빠질 수 있다.

-----------------------------------------

한참이 지나도 답이 나오지 않아 다음 블로그를 참조해 코드를 풀어보았다.

[블로그](https://bladejun.tistory.com/163)

다익스트라 알고리즘을 활용하는것은 동일하지만,

위의 문제를 해결하기 위해 다음과 같은 절차를 따른다.

1. 모든 간선을 양쪽 방향으로 추가한다.


        graph = {i:[] for i in range(1,n+1)}
        for road in roads:
            x, y, cost = road
            graph[x].append([y,cost,0])
            graph[y].append([x,cost,1])

    <br>

2. 함정의 번호와 순서를 이용해 비트 인덱스를 만든다.

        trap_idx ={v:i for i,v in enumerate(traps)}
    
    각 함정의 인덱스값 i는 비트인덱스의 i번째 위치를 뜻한다.
    
    이 위치값을 이용해 함정의 개수만큼의 자릿수를 가지는 비트맵을 만든다.

    예를 들어 4개의 함정 중 1번째, 3번째 함정이 방문되었다면

    0101 = 5 라는 인덱스를 만들 수 있다.
    
    <br>

3. 출발지부터 특정 노드까지 가는 최소거리를 저장하는 리스트를 만든다.


    이 때 이 리스트들은 함정들이 토글되는 가능한 모든 조합만큼 존재한다.

    이 개별 리스트들의 인덱스가 비트로 표현되는 함정들의 비트 인덱스와 동일하다.


        dp = [[INF for _ in range(n+1)] for _ in range(2**len(traps))]

    모든 개별 리스트들은 시작지점부터 각 노드까지의 최소거리를 가지고 있지만,

    특정 함정이 켜지고 꺼질 때 마다 그 인덱스 조합의 위치의 리스트로 이동한다.

    즉 함정 토글 상태가 0101로 변경되면 그때부터는 5번째 리스트의 최소거리를 이용하게 되고,

    이 리스트들의 초기값은 전부 INF이기때문에 언제든 함정에 의해 상태가 변경된다면

    이전에 저장된 최소거리와는 관계 없이 새로운 최소거리를 저장할 수 있게된다. 

    더불어 특정 함정 상태로 다시 돌아오는 무의미한 경우를 방지할 수 있게된다.

    <br>

4. 이후는 일반적인 다익스트라의 흐름을 따르지만, 몇가지 과정이 추가된다.

    1. 함정을 밟을 때 마다 현재 함정 상태를 바꾼다.

    2. 이후 노드로 이동하기 위해 현재노드와 이동할 노드의 함정 상태를 파악해서

        길의 방향이 올바른지 검증한다.

    이것을 가능하게 해주는 것이 bit_mask 함수이다.

        def bit_mask(state, trap_idx, destination, flag):
        if flag == 1: # 특정위치 함정의 토글상태를 반환.
            return (1 & (state >> trap_idx[destination])) 
        else: # 특정위치 함정을 토글. 즉 state를 return
            return state ^ (1 << trap_idx[destination]) 
    
    이 함수는 두 가지 기능을 가지고 있는데,

    현재 함정상태 비트맵에서 특정 위치의 함정이 토글되었는지를 반환하는 기능과,

    현 함정상태에서 특정 위치의 함정을 토글하는 기능이다.

    <br>

    간선의 방향을 확인해야 할 경우는

    현 노드와 다음 노드 중 하나 이상에 함정이 있는 경우이다.

    예를들어 양쪽에 함정이 있는 경우엔 0-1토글상태에 따라 4가지 경우의 수가 있는데,

    이때 이 사이 간선의 방향은 양 토글상태의 xor연산과 동일하다.

        # 다음 목적지도 트랩
                if next_destination in traps:
                    pre = bit_mask(state, trap_idx, current_destination, 1)
                    nxt = bit_mask(state, trap_idx, next_destination, 1)
                    
                    # 이번 간선의 상태는 양쪽 노드의 토글상태에 따라 달라진다.
                    # 합계가 짝수면 0, 홀수면 1이므로 논리적으로 xor연산과 같다.
                    cur_flag = pre ^ nxt
    
    이 함정 노드들의 함정 토글 상태를 파악해 
    
    건너가야하는 간선이 올바른 방향으로 놓여있는지 확인하고,

    올바르다면 그 노드가 선택된다.

    <br>

5. 루프 중 목적지에 도착하면 그 distance를 리턴한다.

    힙큐를 이용해 최소거리가 작은 것 부터 진행되기 때문에 처음으로 리턴되는 값이 최소값이다.


----------------

혼자 구상할 때 비트값을 이용해 함정의 방문여부를 표현하는 것 까지는 생각했지만

중복 노드 방문 처리를 어떻게 할지 까지는 생각이 미치지 못했다.

이를 비트맵으로 묶어서 함정들의 방문상태 경우의 수를 모두 저장하도록 하는것은

효율적이고 신박하게 느껴졌다.

