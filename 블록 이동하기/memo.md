### 블록 이동하기
link : [블록 이동하기](https://programmers.co.kr/learn/courses/30/lessons/60063)

-----------------------------------
BFS를 처음으로 사용한 문제로, 개념을 이해하는데 많은도움을 주었다.

항상 조건을 어렵게 찾으려고 하는게 내 나쁜 버릇이기 때문에,

모든 경우의 수를 탐색한다는 생각이 빨리 떠오르지 않아 고생했다.

특이사항으로는 회전의 경우의 수가 매우 많아 이를 일일이 구현한다면

코드가 굉장히 더러워 질 것이라 생각했다. 

오랜 고민끝에 아래 블로그글을 보고 많은 도움을 받았다.

[블로그](https://yjyoon-dev.github.io/kakao/2021/01/14/kakao-moveblock/)

아래는 블로그글에도움받아 작성한 부분이다. (사실 거의 똑같다.)

        self.my = [-1, 1, 0, 0] # 상, 하, 좌, 우
        self.mx = [ 0, 0,-1, 1]

        def turn(self, direction : int):
        return (Robot(self.y1, self.x1, self.y1 + self.my[direction], self.x1 + self.mx[direction]) ,   # y1,x1이 중심
                Robot(self.y2 + self.my[direction], self.x2 + self.mx[direction], self.y2, self.x2))    # y2, x2가 중심

회전을 할 중심점을 선택하고, 그 중심점에서 상하좌우의 방향으로 나머지 한 점을 ***이어붙이는*** 방식이다.

이 방식대로면 여러가지 복잡한 회전 경우의 수를 모두 생각할 수 있다.

그렇지만 불필요한 경우도 계산이 된다.

예를들어 가로로 놓인 회전체에서 가로 방향으로 이어붙이는 경우이며, 이는 사실상 회전이 아니다.

우측으로 이어붙이는 경우 중심점이 왼쪽이면 제자리이고, 오른쪽이면 우측 평행이동이 된다.

하지만 회전이 아닐 뿐이지 구조 자체가 불가능해지지는 않기 때문에 이것을 checked 셋을 이용한 중복검사로 처리하는것이

회전을 가로, 세로 따로 구현하는 것 보다 간결한 코드로 만들 수 있었다..
