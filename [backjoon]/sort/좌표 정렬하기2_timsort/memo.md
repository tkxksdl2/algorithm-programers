### 좌표 정렬하기 2 
link : [좌표 정렬하기 2](https://www.acmicpc.net/problem/11651)

-----------------------------------
 
 좌표 정렬하기 1번과 전혀 다를 게 없는 문제지만 굳이

 tim sort를 적용해보았다.
 
 tim sort는 insertion과 merge를 적절히 조합한 알고리즘으로 원리는 다음과 같다.

 big-O 표기법에 따르면 상수는 무시된다.

 복잡도가 O(n)이라는 것은 사실 C * n + a 과 같다.

 이떄 상대적으로 영향을 끼치기 힘든 a를 제하면

 O(n) = C * n, O(nlogn) = C * nlogn 이다.

 이 상수 C는 '참조 지역성을 얼마나 만족하는가'에 따라도 영향을 받는다.

 즉 랜덤한 값의 참조보다 인접한 값의 참조가 많이 일어날 수록 실제 메모리를

 참조하는데 걸리는 시간이 상대적으로 짧다는 것이다.

 때문에 연속한 값의 비교가 잦게 일어나는 insertion sort는 참조 지역성의

 원리를 잘 만족한다고 할 수 있다.

 이 C값이 가장 작다고 알려진 퀵 소트의 C를 Cq, insertion을 Ci라고 할때
 
 작은 n값에 한해서 다음이 만족한다.

 Ci * n**2 < Cq * nlogn

 때문에 작은 부분을 먼저 insertion으로 정렬하고, 정렬된 부분들을

 merge로 정렬하면 시간을 단축할 수 있지 않을까 하는 아이디어로 나온 것이

 tim sort이다.

 2**x 개씩 덩어리지어 insertion으로 정렬한 후 merge 한다면,

 덩어리별로 x개의 병합이 생략되어 최종적으로는

 Cm * nlog(n-x) + a 의 복잡도를 가지게 된다.

 --------------------------
 
 이 코드는 실제 tim sort와는 차이가 있다.

 실제 tim sort는 이 Cm값을 줄이고 x값을 늘리기 위해 더 다양한 최적화

 방법을 적용했다.

 이 코드에서 생략된 최적화 방법은 다음과 같다.

 1. insertion을 적용하는 최소 크기(minirun)를 산정한다.

    일반적으로 2**5, 32~64 사이의 값이 산정되는데, 최대한 전체 덩어리 개수가

    2의 제곱수가 되거나 이에 근접할 수 있도록 산정한다.

 2. binary insertion sort를 적용한다. 이는 참조 지역성은 떨어뜨리지만

    삽입정렬 자체를 nlogn으로 만들어준다.

 3. 최소크기(minirun) 만큼 삽입정렬 후 이후값도 정렬되어 있다면 끝값과의

    대소비교 후 그대로 덩어리(run)에 넣어준다. 이는 실생활 데이터는 어느정도 

    정렬되어있을 것이라는 아이디어에 기반한다. 가능한 한 덩어리의 크기를 늘릴 수 있다.

 4. 3번을 위해 덩어리들은 증가하는 덩어리, 감소하는 덩어리로 구분된다.

    첫 두 데이터의 성향에 따라 결정되며, 이후 최종적으로 어떻게 정렬할 지에 따라 반대 방향의 덩어리는 뒤집어준다. 
    
    데이터가 이미 반대 방향으로 정렬되어 있는 경우도 최대한 수용하기 위함이다.

 5. 병합 시 인접한 덩어리(run) 중 최대한 비슷한 크기의 덩어리끼리 병합되도록 한다.

    이를 위해 하나의 덩어리가 생길 때 마다 스택에 push하고, 
    
    이 때마다 첫 세 개의 덩어리 A,B,C에 대해 다음을 검사한다.

    ***각 덩어리의 원소 개수 a, b, c***

    a < b, a + b < c 

    이를 만족하지 않는 경우 b는 a 와 c 중 작은 덩어리와 병합되고,

    병합 후에도 조건이 만족되지 않으면 다시 병합을 반복한다.

    이 방법을 이용하면 첫째로, 스택의 크기를 작게 유지할 수 있고,

    둘째로 최대한 비슷한 크기의 덩어리끼리 결합시킬 수 있다.

 6. Galloping(질주) 모드

    두 덩어리를 병합할 때 한 덩어리에서 연속으로 참조가 일어날 수 있다.

    예를들어 다음 두 덩어리가 있다고 치자.

    A =[1, 2, 3, 4, 5,...,50]

    B =[70, 80, 90, 100, 110,...]

    이 경우 A의 모든 값을 참조할동안 B에선 한 값만 참조된다.

    이렇게 연속으로 한 덩어리만 참조될경우, 앞으로도 이러한 경향이 있을것이라고 판단해 질주 모드에 들어간다.

    질주모드에 들어가면 2**x ...(2,4,8,16...) 만큼 건너뛰어가며 참조가 일어난다.

    이후 어떤 지점에서 대소의 방향이 기존과 바뀌면(혹은 범위가 끝나면)

    마지막 질주 범위 내에서 이진탐색을 시작해 정확한 위치를 특정한다.

-----------------------------------

 tim sort는 사실 정해진 알고리즘이라보다는 데이터의 특성에 따라

 튜닝하는 메소드에 가깝다. 때문에 많은 부분을 생략해 삽입과

 병합을 결합하는 부분 정도만 구현했다.

 그래서 이 문제에서도 딱히 일반적인 merge보다 속도가 빠르지도 않았다.

 하지만 애초에 python과 같은 interpreter 언어를 위해 고안된 알고리즘이니만큼 공부할 의미는 있었다.

