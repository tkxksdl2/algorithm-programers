### 증가하는 부분수열
link : [증가하는 부분수열](https://www.acmicpc.net/problem/11053)

---------------------------------

처음에는 입력 리스트의 특정 자리에서 최대 부분수열의 길이를 저장해보려했다.

하지만 진행하다보니 여러 수열이 뒤죽박죽으로 생길 수 있고,

특정 수열이 이어지는지 확인하려면 각 수열의 마지막 값이 필요하다는 것을 알게 되었다.

하지만 생성되는 모든 수열을 저장하는건 너무 비효율적이다.

때문에 메모이제이션 arr를 " ***가장 최근 생긴 길이가 i인 수열의 마지막 값*** " 으로 설정했다.

---------------------------------

메모이제이션 last_arr 는 다음과 같다.

last_arr[i] 는 가장 최근에 갱신된 길이가 i인 부분수열의 마지막 값이다.

입력 리스트 lst가 [1, 2, 3] 이면 last_arr 역시 [1, 2, 3] 이다.

입력 리스트로부터 특정 값이 들어오면 last_arr에서 값을 비교해가며 자리를 찾는다.

'자리'란 입력된 값이 끝값이 될 수 있는 부분수열의 자릿수를 뜻한다.

만약 여기서 10이 들어오면 다음과 같다.

    lst = [1, 2, 3, 10]
    last_arr = [1, 2, 3, 10]

길이가 3인 부분수열 마지막 값 3보다 더 큰 값이 들어왔기 때문에, 부분수열은 이어지고 

길이가 4인 부분수열이 생겼다. 이 수열의 마지막 값은 10이다.

여기서 더 작은 값이 들어오면 다음과 같다.

    lst = [1, 2, 3, 10, 4]
    last_arr = [1, 2, 3, 4]

길이가 3인 부분수열 마지막 값 3보다 더 큰 값이 들어왔기 때문에 부분수열은 이어지고

길이가 4인 부분수열이 하나 더 생겼다. 즉 끝값이 4인 부분수열과 끝값이 10인 부분수열이다.

그러나 여기서 값이 10인 부분수열은 기억할 필요가 없다.

길이가 같은 부분수열일 경우에 최근에 갱신된 부분수열이 무조건 끝값이 더 작거나 같다.

그래서 어떤숫자가 들어오든 끝값이 10인 부분수열이 이어진다면 끝값이 4인 부분수열도 이어진다.

즉 갱신된 부분수열이 이전 부분수열을 완벽히 대체하므로 기억 할 필요가 없다.

----------------------------

이렇게 특정 값이 들어올 때 마다 길이가 i 인 부분수열들의 끝값들과 비교하여,

특정 부분수열을 대체하거나 부분수열의 최대 길이를 늘린다.

아래 경우를 생각해보자.

    lst =       [1, 2, 3, 10, 11, 12, 6, 7, 100]
    last_arr =  [1, 2, 3, 6, 7, 12, 100]

12 까지 길이가 6인 부분수열이 생겼다가,

6, 7이 들어와 길이가 4,5 인 부분수열을 대체했다.

그리고 100이 들어와 길이가 7인 부분수열이 생겼고, 최대 길이는 7이다.

여기에는 사실 길이가 6인 부분수열 [1, 2, 3, 6, 7, 100]도 존재한다.

하지만 끝값이 100으로 길이가 7인 부분수열과 같기 때문에,

어떤 수가 들어오든 이 수열이 이어진다면 길이가 7인 부분수열도 이어진다.

이 때문에 끝값 갱신은 가능한 가장 긴 부분수열에서 한번만 하는 것이고, 

발전가능성이 없는 부분수열은 자연히 고려되지 않는다.

---------------------------------------------

마지막으로 메모이제이션 last_arr 의 형태를 보면 다음과 같다.

    [1, 2, 3, 6, 7, 12, 100]

끝값의 대소관계를 비교해가며 입력되기 때문에 이 리스트는 항상 정렬되어있다.

즉 끝값의 대소관계를 비교하여 자릿수를 찾는 과정에 이진탐색을 적용할 수 있다.

```python
    last_arr = [lst[0]]

    for i in range(1, n):
        ## 여기서 이진탐색으로 자리를 찾는다.
        idx = bisect(last_arr, lst[i], 0, len(last_arr))
        if idx >= len(last_arr):
            last_arr.append(lst[i])
        else:
            last_arr[idx] = lst[i]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def bisect(arr, num, s, e):
    if e-s < 1:
        return s

    m = (s + e) // 2
    if num <= arr[m]:
        return bisect(arr, num, s, m)
    else:
        return bisect(arr, num, m+1 ,e)
```