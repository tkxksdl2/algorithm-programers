### 합승 택시 요금
link : [합승 택시 요금 카카오 2021 ](https://programmers.co.kr/learn/courses/30/lessons/72413)

-----------------------------------

노드를 탐색하는 경로 문제. 목적지는 두 종류가 있고,

이 두 목적지까지 가는 경로 두 개가 얼마나 겹치는가에 따라 비용이 낮아지고,

이 중 가장 비용이 낮은 경우의 수의 비용을 찾는 문제.

일단 경로를 탐색한다는 것 부터 dfs를 사용해야 한다고 생각했다.

그래서 처음에 dfs를 이용해 각 목적지까지 가는 모든경우의 수를 찾아내는 것에 성공했다.

그러나 이 방법으로는 그 이후 각 경로가 겹치는 부분을 검사할 때

모든 a루트 경로 * 모든 b 루트 경로 의 복잡도를 가지게 되기 때문에

너무 많은 시간이 걸렸다.

새로운 방법을 찾아내야 할 필요가 있다.

------------------------------------

새로운 방법으로 최소경로를 구하는 두 가지 알고리즘을 찾아보았다.

플로이드 와샬 알고리즘과 다익스트라 알고리즘을 사용하는데,

먼저 플로이드 와샬 알고리즘을 사용해서 문제를 풀었다.

이는 출발지와 목적지 사이에 중간지점을 둠으로써 중간지점을 거치는 거리가 더 짧다면

최소거리를 갱신하는 알고리즘이다

시작지, 목적지, 중간지점까지 세번의 n루프를 돌아야 하기 때문에

O(N^3)의 복잡도를 가지지만, 노드개수인 N은 최대가 200 뿐이므로 문제풀이가 가능했다.

    for k in range(1, n+1):
        for start in range(1, n+1):
            for end in range(1, n+1):
                if fares_dict[start][end] > fares_dict[start][k] + fares_dict[k][end]:
                    fares_dict[start][end] = fares_dict[start][k] + fares_dict[k][end]
        
    answer = INF
    for k in range(1, n+1):
        answer = min(fares_dict[s][k] + fares_dict[k][a] + fares_dict[k][b], answer)

노드 비용 그래프를 잘 초기화 해놓는다면 이렇게 알고리즘 부분 코드가 간단해진다.